import bitstream, algorithm

type
  HuffmanTree* = ref object
    nodes: array[1024, int]
    root: HuffmanNode
  HuffmanNode = ref object
    symbol: int
    case isLeaf: bool
    of true: left, right: HuffmanNode
    of false: discard
  Symbol = tuple[len: CodeLen, code: int]
  # Safe bit storage
  CodeLenBits {.size: sizeof(cint).} = enum
    A, B, C, D
  CodeLen = set[CodeLenBits]

proc toNum(bits: CodeLen): int = cast[cint](bits)
proc toBits(b: byte): CodeLen = cast[CodeLen](b)
proc `<`(x, y: CodeLen): bool = x.toNum < y.toNum

proc newHuffmanTree*(input: openArray[byte]): HuffmanTree =
  # The input is 256 bytes.
  # It consists of 512 numbers that represent bit lengths of symbols.
  # Each number is stored in 4 bits.
  # For each bytes, the least significant bits should be read first.
  # The first 256 symbols represent ascii characters.
  # The remaining 256 symbols represent references to compressed tuples.
  var symbols {.noInit.}: array[512, Symbol]

  for i in 0 ..< 256:
    let b = input[i]
    symbols[2*i]   = (toBits(b and 15), 2*i)
    symbols[2*i+1] = (toBits(b shr 4), 2*i+1)

  sort symbols

  # Testing
  when isMainModule:
    for s in symbols:
      echo $s.code & ": " & $s.len.toNum

  # Skip unused symbols
  var i: int
  while i < 512 and toNum(symbols[0].len) == 0: inc i

proc read(tree: HuffmanTree): int = discard

# Testing
when isMainModule:
  let
    input = @[0xC5'u8, 0xB7, 0xA6, 0xBA, 0xCA, 0xB7, 0xBB, 0xBB,
                 0xBA, 0xA7, 0xBB, 0xBC, 0xCA, 0xC7, 0xCC, 0xBC,
                 0xC9, 0xC7, 0xBC, 0xBC, 0xC9, 0xC7, 0x9B, 0xC9,
                 0xA9, 0xA7, 0xAA, 0x99, 0xA9, 0xC7, 0xBC, 0xBD,
                 0x89, 0x87, 0x88, 0x99, 0x99, 0xA7, 0x98, 0x99,
                 0xB8, 0x96, 0x98, 0x99, 0xA9, 0xC7, 0xB8, 0xBA,
                 0xC9, 0xB7, 0xCB, 0xBB, 0xD9, 0xB7, 0xCB, 0xBB,
                 0xCA, 0xC7, 0xBB, 0xBB, 0xD9, 0xB7, 0xBB, 0xCA,
                 0xBA, 0xB7, 0xCB, 0xCB, 0xCA, 0xB7, 0xCB, 0xCC,
                 0xBA, 0xB7, 0xBC, 0xBC, 0xBA, 0x07, 0xBC, 0xCB,
                 0xDA, 0xD7, 0xBD, 0xAB, 0xB9, 0xD7, 0xBC, 0xCB,
                 0x09, 0xD7, 0xC0, 0xBC, 0xC9, 0xD7, 0xCC, 0xCB,
                 0xB9, 0xB7, 0xBC, 0xCB, 0xBA, 0xC7, 0xBD, 0xBB,
                 0xCA, 0xC7, 0xCD, 0xDB, 0xB9, 0xC7, 0xBC, 0xCC,
                 0xCA, 0xC7, 0xBB, 0xBD, 0xCB, 0xD7, 0xBB, 0xBB,
                 0xCA, 0xC7, 0xCC, 0xAB, 0xB9, 0xC7, 0xCC, 0xAD,
                 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
                 0x7A, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0xD0,
                 0x98, 0xA8, 0xB2, 0x0D, 0xD0, 0x00, 0xD0, 0xD0,
                 0x98, 0xC9, 0xC5, 0x00, 0xD0, 0x00, 0x00, 0xC0,
                 0x96, 0xBC, 0xB8, 0x00, 0xC9, 0x00, 0xAB, 0xA0,
                 0x98, 0xBD, 0x99, 0xC0, 0xAB, 0x00, 0x9A, 0x90,
                 0x98, 0x9B, 0x88, 0xC0, 0xBB, 0xC0, 0x9C, 0x80,
                 0x97, 0xAA, 0x78, 0xCD, 0xAB, 0x0D, 0x8B, 0x80,
                 0x87, 0xA9, 0x88, 0x00, 0xBB, 0xDD, 0x9D, 0x8D,
                 0x87, 0xA9, 0x88, 0xDC, 0xBC, 0x0C, 0xB0, 0x80,
                 0x87, 0xA9, 0x98, 0xDC, 0xDC, 0x0A, 0xC0, 0x8D,
                 0x90, 0xA8, 0xA8, 0xDB, 0xCD, 0xCA, 0xDC, 0x9D,
                 0xA0, 0xBA, 0xDA, 0xDC, 0x0C, 0x0C, 0xDD, 0xA0,
                 0xA0, 0xCA, 0xCC, 0x0D, 0xDD, 0x00, 0x00, 0xC0,
                 0x00, 0x0B, 0xDD, 0x0D, 0x0D, 0x00, 0x00, 0xC0]

    ht = newHuffmanTree(input)

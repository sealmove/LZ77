import bitstream, algorithm

type
  HuffmanNode* = ref object
    case isLeaf: bool
    of true: code: int
    of false: children: array[2, HuffmanNode]
  Symbol = tuple[code: int, length: CodeLen]
  # Safe bit storage
  CodeLenBits {.size: sizeof(cint).} = enum
    A, B, C, D
  CodeLen = set[CodeLenBits]

proc toNum(bits: CodeLen): int = cast[cint](bits)
proc len(s: Symbol): int = toNum(s.length)
proc toBits(b: byte): CodeLen = cast[CodeLen](b)
proc compare(a, b: Symbol): int =
  if a.len < b.len: -1
  elif a.len > b.len: 1
  elif a.code < b.code: -1
  elif a.code > b.code: 1
  else: 0

proc addLeaf(nodes: var array[1024, HuffmanNode]; leaf, mask, bits: int): int =
  var
    mask = mask
    bits = bits
    i = leaf + 1
    node = nodes[0]
  while bits > 1:
    dec bits
    let bit = (mask shr bits) and 1
    if node.children[bit] == nil:
      nodes[i] = new(HuffmanNode)
      node.children[bit] = nodes[i]
      inc i
    node = node.children[bit]
  node.children[mask and 1] = nodes[leaf]
  return i

proc newHuffmanTree*(input: openArray[byte]): HuffmanNode =
  # The input is 256 bytes.
  # It consists of 512 numbers that represent bit lengths of symbols.
  # Each number is stored in 4 bits.
  # For each bytes, the least significant bits should be read first.
  # The first 256 symbols represent ascii characters.
  # The remaining 256 symbols represent references to compressed tuples.
  var
    symbols: array[512, Symbol]
    nodes: array[1024, HuffmanNode]

  nodes[0] = new(HuffmanNode)
  result = nodes[0]

  for i in 0 ..< 256:
    let b = input[i]
    symbols[2*i]   = (2*i, toBits(b and 15))
    symbols[2*i+1] = (2*i+1, toBits(b shr 4))

  symbols.sort(compare)

  # Skip unused symbols
  var x: int; while x < 512 and symbols[x].len == 0: inc x

  var
    j = 1
    mask, bits: int

  for i in x ..< 512:
    nodes[j] = HuffmanNode(isLeaf: true, code: symbols[i].code)
    mask = mask shl (symbols[i].len - bits)
    bits = symbols[i].len
    j = nodes.addLeaf(j, mask, bits)
    inc mask

proc decode*(root: HuffmanNode, bs: BitStream): int =
  var
    bit: uint
    node = root
  while not node.isLeaf:
    bit = bs.read(1)
    node = node.children[bit]
  result = node.code

# Testing
when isMainModule:
  let
    input = @[0xC5'u8, 0xB7, 0xA6, 0xBA, 0xCA, 0xB7, 0xBB, 0xBB,
                 0xBA, 0xA7, 0xBB, 0xBC, 0xCA, 0xC7, 0xCC, 0xBC,
                 0xC9, 0xC7, 0xBC, 0xBC, 0xC9, 0xC7, 0x9B, 0xC9,
                 0xA9, 0xA7, 0xAA, 0x99, 0xA9, 0xC7, 0xBC, 0xBD,
                 0x89, 0x87, 0x88, 0x99, 0x99, 0xA7, 0x98, 0x99,
                 0xB8, 0x96, 0x98, 0x99, 0xA9, 0xC7, 0xB8, 0xBA,
                 0xC9, 0xB7, 0xCB, 0xBB, 0xD9, 0xB7, 0xCB, 0xBB,
                 0xCA, 0xC7, 0xBB, 0xBB, 0xD9, 0xB7, 0xBB, 0xCA,
                 0xBA, 0xB7, 0xCB, 0xCB, 0xCA, 0xB7, 0xCB, 0xCC,
                 0xBA, 0xB7, 0xBC, 0xBC, 0xBA, 0x07, 0xBC, 0xCB,
                 0xDA, 0xD7, 0xBD, 0xAB, 0xB9, 0xD7, 0xBC, 0xCB,
                 0x09, 0xD7, 0xC0, 0xBC, 0xC9, 0xD7, 0xCC, 0xCB,
                 0xB9, 0xB7, 0xBC, 0xCB, 0xBA, 0xC7, 0xBD, 0xBB,
                 0xCA, 0xC7, 0xCD, 0xDB, 0xB9, 0xC7, 0xBC, 0xCC,
                 0xCA, 0xC7, 0xBB, 0xBD, 0xCB, 0xD7, 0xBB, 0xBB,
                 0xCA, 0xC7, 0xCC, 0xAB, 0xB9, 0xC7, 0xCC, 0xAD,
                 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
                 0x7A, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x00, 0xD0,
                 0x98, 0xA8, 0xB2, 0x0D, 0xD0, 0x00, 0xD0, 0xD0,
                 0x98, 0xC9, 0xC5, 0x00, 0xD0, 0x00, 0x00, 0xC0,
                 0x96, 0xBC, 0xB8, 0x00, 0xC9, 0x00, 0xAB, 0xA0,
                 0x98, 0xBD, 0x99, 0xC0, 0xAB, 0x00, 0x9A, 0x90,
                 0x98, 0x9B, 0x88, 0xC0, 0xBB, 0xC0, 0x9C, 0x80,
                 0x97, 0xAA, 0x78, 0xCD, 0xAB, 0x0D, 0x8B, 0x80,
                 0x87, 0xA9, 0x88, 0x00, 0xBB, 0xDD, 0x9D, 0x8D,
                 0x87, 0xA9, 0x88, 0xDC, 0xBC, 0x0C, 0xB0, 0x80,
                 0x87, 0xA9, 0x98, 0xDC, 0xDC, 0x0A, 0xC0, 0x8D,
                 0x90, 0xA8, 0xA8, 0xDB, 0xCD, 0xCA, 0xDC, 0x9D,
                 0xA0, 0xBA, 0xDA, 0xDC, 0x0C, 0x0C, 0xDD, 0xA0,
                 0xA0, 0xCA, 0xCC, 0x0D, 0xDD, 0x00, 0x00, 0xC0,
                 0x00, 0x0B, 0xDD, 0x0D, 0x0D, 0x00, 0x00, 0xC0]

    ht = newHuffmanTree(input)
